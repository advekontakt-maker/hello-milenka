<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Skibidi</title>
  <link rel="stylesheet" href="styles.css">
</head>
<body>
  <div class="container">
    <button class="btn" id="loveBtn">Kliknij ≈ºeby odkryƒá niespodziankƒô</button>
    
    <div class="paper-card" id="paperCard" style="display: none;">
      <svg class="burn-svg" viewBox="0 0 800 1000" preserveAspectRatio="none">
        <defs>
          <filter id="burnBlur">
            <feGaussianBlur in="SourceGraphic" stdDeviation="3" />
          </filter>
          <radialGradient id="burnGrad1" cx="0%" cy="0%">
            <stop offset="0%" style="stop-color:#000000;stop-opacity:0.95" />
            <stop offset="20%" style="stop-color:#2d1810;stop-opacity:0.88" />
            <stop offset="50%" style="stop-color:#8b4513;stop-opacity:0.6" />
            <stop offset="100%" style="stop-color:#ffffff;stop-opacity:0" />
          </radialGradient>
          <radialGradient id="burnGrad2" cx="100%" cy="0%">
            <stop offset="0%" style="stop-color:#000000;stop-opacity:0.95" />
            <stop offset="20%" style="stop-color:#2d1810;stop-opacity:0.88" />
            <stop offset="50%" style="stop-color:#8b4513;stop-opacity:0.6" />
            <stop offset="100%" style="stop-color:#ffffff;stop-opacity:0" />
          </radialGradient>
          <radialGradient id="burnGrad3" cx="0%" cy="100%">
            <stop offset="0%" style="stop-color:#000000;stop-opacity:0.95" />
            <stop offset="20%" style="stop-color:#2d1810;stop-opacity:0.88" />
            <stop offset="50%" style="stop-color:#8b4513;stop-opacity:0.6" />
            <stop offset="100%" style="stop-color:#ffffff;stop-opacity:0" />
          </radialGradient>
          <radialGradient id="burnGrad4" cx="100%" cy="100%">
            <stop offset="0%" style="stop-color:#000000;stop-opacity:0.95" />
            <stop offset="20%" style="stop-color:#2d1810;stop-opacity:0.88" />
            <stop offset="50%" style="stop-color:#8b4513;stop-opacity:0.6" />
            <stop offset="100%" style="stop-color:#ffffff;stop-opacity:0" />
          </radialGradient>
        </defs>
        <!-- Top right burn -->
        <circle cx="750" cy="50" r="150" fill="url(#burnGrad1)" filter="url(#burnBlur)" />
        <path d="M 800 0 Q 750 30 700 80 L 800 0 Z" fill="#1a0f05" opacity="0.7" />
        <!-- Top left burn -->
        <circle cx="50" cy="50" r="150" fill="url(#burnGrad2)" filter="url(#burnBlur)" />
        <path d="M 0 0 Q 50 30 100 80 L 0 0 Z" fill="#1a0f05" opacity="0.7" />
        <!-- Bottom right burn -->
        <circle cx="750" cy="950" r="150" fill="url(#burnGrad3)" filter="url(#burnBlur)" />
        <path d="M 800 1000 Q 750 970 700 920 L 800 1000 Z" fill="#1a0f05" opacity="0.7" />
        <!-- Bottom left burn -->
        <circle cx="50" cy="950" r="150" fill="url(#burnGrad4)" filter="url(#burnBlur)" />
        <path d="M 0 1000 Q 50 970 100 920 L 0 1000 Z" fill="#1a0f05" opacity="0.7" />
      </svg>
      <button class="close-btn" id="closePaperBtn">&times;</button>
      <div class="paper-content">
        <p>KOCHAM CIƒò M√ìJ SKARBIE ‚ù§Ô∏è</p>
      </div>
    </div>

    <div class="puzzle-modal" id="puzzleModal" style="display: none;">
      <div class="puzzle-container">
        <div class="puzzle-message" id="puzzleMessage">u≈Ç√≥≈º puzzle, ≈ºeby przej≈õƒá dalej</div>
        <div class="puzzle-board" id="puzzleBoard"></div>
        <div class="puzzle-slots" id="puzzleSlots"></div>
      </div>
    </div>
  </div>

  <script>
    const btn = document.getElementById('loveBtn');
    const container = document.querySelector('.container');

    const heartEmojis = ['‚ù§', 'üíó', 'üíñ', 'üíû', 'üíï', '‚ù£Ô∏è'];

    btn.addEventListener('click', (e) => {
      // get button bounds to spawn hearts all over it
      const btnRect = btn.getBoundingClientRect();
      const btnWidth = btnRect.width;
      const btnHeight = btnRect.height;
      const btnCenterX = btnRect.left + btnWidth / 2;
      const btnCenterY = btnRect.top + btnHeight / 2;

      // create a burst of hearts and occasional sparkles
      for (let i = 0; i < 15; i++) {
        // random position within and around the button area
        const randomX = btnRect.left + Math.random() * btnWidth;
        const randomY = btnRect.top + Math.random() * btnHeight;
        createHeart(randomX, randomY);
        if (Math.random() < 0.4) createSpark(btnCenterX, btnCenterY);
      }

      // after animation, create a new button
      setTimeout(() => {
        createNewButton();
      }, 600);
    });

    function createHeart(x, y) {
      const heart = document.createElement('span');
      heart.className = 'heart';
      heart.innerText = heartEmojis[Math.floor(Math.random() * heartEmojis.length)];

      const rect = container.getBoundingClientRect();
      const left = x - rect.left - 12;
      const top = y - rect.top - 12;

      heart.style.left = left + 'px';
      heart.style.top = top + 'px';
      heart.style.pointerEvents = 'none'; // prevent blocking clicks

      const size = Math.floor(Math.random() * 22) + 16;
      heart.style.fontSize = size + 'px';
      heart.style.opacity = (Math.random() * 0.4 + 0.6).toString();

      const dx = Math.floor((Math.random() - 0.5) * 220);
      const rot = Math.floor((Math.random() - 0.5) * 720);
      const dur = (1.2 + Math.random() * 1.4).toFixed(2) + 's';

      heart.style.setProperty('--dx', dx + 'px');
      heart.style.setProperty('--rot', rot + 'deg');
      heart.style.setProperty('--dur', dur);
      heart.style.animationDuration = dur;

      container.appendChild(heart);

      // ensure heart is removed after animation completes
      const animationDuration = parseFloat(dur) * 1000;
      setTimeout(() => {
        if (heart.parentNode) {
          heart.remove();
        }
      }, animationDuration + 200);
    }

    function createSpark(x, y) {
      const spark = document.createElement('span');
      spark.className = 'spark';
      const rect = container.getBoundingClientRect();
      const left = x - rect.left - 4 + (Math.random() - 0.5) * 24;
      const top = y - rect.top - 4 + (Math.random() - 0.5) * 12;
      spark.style.left = left + 'px';
      spark.style.top = top + 'px';
      container.appendChild(spark);
      setTimeout(() => spark.remove(), 1000);
    }

    function createNewButton() {
      const newBtn = document.createElement('button');
      newBtn.className = 'btn btn-appear';
      newBtn.innerText = 'Spr√≥buj jeszcze raz';
      
      // replace the old button with new one in the DOM
      btn.parentNode.replaceChild(newBtn, btn);
      
      // create burst particles around new button
      const newBtnRect = newBtn.getBoundingClientRect();
      const centerX = newBtnRect.left + newBtnRect.width / 2;
      const centerY = newBtnRect.top + newBtnRect.height / 2;
      
      for (let i = 0; i < 8; i++) {
        const angle = (i / 8) * Math.PI * 2;
        const distance = 80;
        const x = centerX + Math.cos(angle) * distance;
        const y = centerY + Math.sin(angle) * distance;
        createBurstParticle(x, y, angle);
      }
      
      // attach click listener to new button
      newBtn.addEventListener('click', (e) => {
        // get button bounds to spawn hearts all over it
        const btnRect = newBtn.getBoundingClientRect();
        const btnWidth = btnRect.width;
        const btnHeight = btnRect.height;
        const btnCenterX = btnRect.left + btnWidth / 2;
        const btnCenterY = btnRect.top + btnHeight / 2;

        // create a burst of hearts and occasional sparkles
        for (let i = 0; i < 15; i++) {
          const randomX = btnRect.left + Math.random() * btnWidth;
          const randomY = btnRect.top + Math.random() * btnHeight;
          createHeart(randomX, randomY);
          if (Math.random() < 0.4) createSpark(btnCenterX, btnCenterY);
        }

        // create button with "Co≈õ nie pyk≈Ço" text
        setTimeout(() => {
          createThirdButton();
        }, 600);
      });
    }

    function createThirdButton() {
      const thirdBtn = document.createElement('button');
      thirdBtn.className = 'btn btn-appear';
      thirdBtn.innerText = 'Co≈õ nie pyk≈Ço';
      
      // replace the second button with third one in the DOM
      const currentBtn = container.querySelector('.btn');
      currentBtn.parentNode.replaceChild(thirdBtn, currentBtn);
      
      // create burst particles around third button
      const thirdBtnRect = thirdBtn.getBoundingClientRect();
      const centerX = thirdBtnRect.left + thirdBtnRect.width / 2;
      const centerY = thirdBtnRect.top + thirdBtnRect.height / 2;
      
      for (let i = 0; i < 8; i++) {
        const angle = (i / 8) * Math.PI * 2;
        const distance = 80;
        const x = centerX + Math.cos(angle) * distance;
        const y = centerY + Math.sin(angle) * distance;
        createBurstParticle(x, y, angle);
      }
      
      // attach click listener to third button
      thirdBtn.addEventListener('click', (e) => {
        // get button bounds to spawn hearts all over it
        const btnRect = thirdBtn.getBoundingClientRect();
        const btnWidth = btnRect.width;
        const btnHeight = btnRect.height;
        const btnCenterX = btnRect.left + btnWidth / 2;
        const btnCenterY = btnRect.top + btnHeight / 2;

        // create a burst of hearts and occasional sparkles
        for (let i = 0; i < 15; i++) {
          const randomX = btnRect.left + Math.random() * btnWidth;
          const randomY = btnRect.top + Math.random() * btnHeight;
          createHeart(randomX, randomY);
          if (Math.random() < 0.4) createSpark(btnCenterX, btnCenterY);
        }

        // show the paper card after a short delay
        setTimeout(() => {
          showPaperCard();
        }, 400);
      });
    }

    function createBurstParticle(x, y, angle) {
      const particle = document.createElement('span');
      particle.className = 'burst-particle';
      particle.innerHTML = ['‚ú®', 'üí´', '‚≠ê'][Math.floor(Math.random() * 3)];
      
      const rect = container.getBoundingClientRect();
      particle.style.left = (x - rect.left) + 'px';
      particle.style.top = (y - rect.top) + 'px';
      particle.style.position = 'absolute';
      particle.style.fontSize = '20px';
      particle.style.pointerEvents = 'none';
      particle.style.willChange = 'transform, opacity';
      
      // calculate translation
      const distance = 120;
      const tx = Math.cos(angle) * distance;
      const ty = Math.sin(angle) * distance;
      
      particle.style.setProperty('--tx', tx + 'px');
      particle.style.setProperty('--ty', ty + 'px');
      particle.style.animation = `burstFloat 0.8s ease-out forwards`;
      
      container.appendChild(particle);
      setTimeout(() => {
        if (particle.parentNode) {
          particle.remove();
        }
      }, 900);
    }

    function showPaperCard() {
      const puzzleModal = document.getElementById('puzzleModal');
      const puzzleBoard = document.getElementById('puzzleBoard');
      const puzzleSlots = document.getElementById('puzzleSlots');
      
      // Clear previous puzzle
      puzzleBoard.innerHTML = '';
      puzzleSlots.innerHTML = '';
      
      // Show puzzle message first and disable page scrolling
      puzzleModal.style.display = 'flex';
      const prevOverflow = document.body.style.overflow;
      document.body.style.overflow = 'hidden';

      // prevent touchmove from triggering pull-to-refresh or page scroll while modal is open
      puzzleModal.ontouchmove = function(ev) { ev.preventDefault(); };

      // Show puzzle elements after 3 seconds
      setTimeout(() => {
        // Create puzzle pieces (numbers 1-3 shuffled)
        const numbers = [1, 2, 3];
        const shuffled = numbers.sort(() => Math.random() - 0.5);
        const correctOrder = [1, 2, 3];
        
        // Create slots first (in correct order)
        correctOrder.forEach((num, idx) => {
          const slot = document.createElement('div');
          slot.className = 'puzzle-slot';
          slot.dataset.correctNum = num;
          slot.dataset.index = idx;
          slot.id = `slot-${idx}`;
          puzzleSlots.appendChild(slot);
        });
        
        // Create draggable pieces
        shuffled.forEach(num => {
          const piece = document.createElement('div');
          piece.className = 'puzzle-piece';
          piece.textContent = num;
          piece.draggable = true;
          piece.dataset.num = num;
          let isDragging = false;
          
          piece.addEventListener('dragstart', (e) => {
            e.dataTransfer.effectAllowed = 'move';
            e.dataTransfer.setData('text/plain', num);
            piece.classList.add('dragging');
            isDragging = true;
          });
          
          piece.addEventListener('dragend', () => {
            piece.classList.remove('dragging');
            isDragging = false;
          });

          // Touch support for mobile
          piece.addEventListener('touchstart', (e) => {
            e.preventDefault();
            piece.classList.add('dragging');
            piece.dataset.touchX = e.touches[0].clientX;
            piece.dataset.touchY = e.touches[0].clientY;
          });

          piece.addEventListener('touchend', (e) => {
            const touch = e.changedTouches[0];
            const element = document.elementFromPoint(touch.clientX, touch.clientY);
            const slot = element?.closest('.puzzle-slot');
            
            if (slot) {
              const correctNum = parseInt(slot.dataset.correctNum);
              if (num === correctNum) {
                const content = document.createElement('div');
                content.className = 'puzzle-slot-content';
                content.textContent = num;
                slot.innerHTML = '';
                slot.appendChild(content);
                slot.classList.add('filled');
                piece.remove();
                setTimeout(checkPuzzleComplete, 300);
              }
            }
            piece.classList.remove('dragging');
          });
          
          puzzleBoard.appendChild(piece);
        });

        // Add drag handlers to slots
        const slots = document.querySelectorAll('.puzzle-slot');
        slots.forEach(slot => {
          slot.addEventListener('dragover', (e) => {
            e.preventDefault();
            e.dataTransfer.dropEffect = 'move';
            slot.style.background = '#FFE4F0';
          });
          
          slot.addEventListener('dragleave', () => {
            slot.style.background = '#f0f0f0';
          });
          
          slot.addEventListener('drop', (e) => {
            e.preventDefault();
            const num = parseInt(e.dataTransfer.getData('text/plain'));
            const correctNum = parseInt(slot.dataset.correctNum);
            
            if (num === correctNum) {
              const content = document.createElement('div');
              content.className = 'puzzle-slot-content';
              content.textContent = num;
              slot.innerHTML = '';
              slot.appendChild(content);
              slot.classList.add('filled');
              
              // Remove piece from board
              const piece = document.querySelector(`[data-num="${num}"]`);
              if (piece) piece.remove();
              
              // Check if all slots are filled
              setTimeout(checkPuzzleComplete, 300);
            } else {
              slot.style.background = '#f0f0f0';
            }
          });
        });

        // allow closing puzzle modal by tapping outside or cancel (restore scrolling)
        puzzleModal.addEventListener('click', (ev) => {
          if (ev.target === puzzleModal) {
            puzzleModal.style.display = 'none';
            document.body.style.overflow = prevOverflow || '';
            puzzleModal.ontouchmove = null;
          }
        });
      }, 3000);
    }
    
    function checkPuzzleComplete() {
      const slots = document.querySelectorAll('.puzzle-slot');
      const allFilled = Array.from(slots).every(slot => slot.classList.contains('filled'));
      
      if (allFilled) {
        setTimeout(() => {
          const puzzleModal = document.getElementById('puzzleModal');
          puzzleModal.style.display = 'none';
          // restore body scroll and remove touchmove blocker
          document.body.style.overflow = '';
          puzzleModal.ontouchmove = null;
          const paperCard = document.getElementById('paperCard');
          paperCard.style.display = 'flex';
          
          // Attach close button listener
          const closeBtn = document.getElementById('closePaperBtn');
          closeBtn.addEventListener('click', () => {
            paperCard.style.display = 'none';
          });
        }, 500);
      }
    }
  </script>

</body>
</html>
